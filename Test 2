import numpy as np
from scipy.integrate import solve_ivp
from skopt import Optimizer
from skopt.space import Real
from skopt.sampler import Lhs, Sobol
import threading
from jinja2 import Environment, FileSystemLoader


from bokeh.plotting import figure, curdoc
from bokeh.layouts import column, row, layout # Import layout here
from bokeh.models import (
    ColumnDataSource,
    Button,
    Select,
    Div,
    Spinner,
    Paragraph,
    DataTable,
    TableColumn,
    NumberFormatter,
    RangeSlider,
    LinearAxis,
    DataRange1d,
    NumeralTickFormatter,
    FixedTicker,
    CustomJS,
    Tabs, # Import Tabs
    TabPanel # Import TabPanel
)
from bokeh.embed import components # IMPORTANT: Need this for components()
from bokeh.resources import CDN # IMPORTANT: Need this for CDN to load BokehJS from web


# --- 5. Bokeh Application Setup ---
# Initialize the Bokeh document object as early as possible
doc = curdoc()
doc.title = "Lutein Production Optimizer" # This sets the browser tab title


# --- 1. Define Model Parameters (Constants of the Lutein system) ---
U_M = 0.152
U_D = 5.95e-3
K_N = 30.0e-3
Y_NX = 0.305
K_M = 0.350e-3 * 2
K_D = 3.71 * 0.05 / 90
K_NL = 10.0e-3
K_S = 142.8
K_I = 214.2
K_SL = 320.6
K_IL = 480.9
TAU = 0.120
KA = 0.0

# --- Cost and Process Constants ---
VOLUME_L = 500  # L
AREA_M2 = 1.26  # m^2
EFFICIENCY = 2e-6  # micromol/J to mol/J

# Prices
PRICE_BIOMASS_PER_G = 0.01  # $/g for biomass
PRICE_NITROGEN_PER_G = 0.40  # $/g for nitrogen
PRICE_ENERGY_PER_KWH = 0.15  # $/kWh for energy
PRICE_LUTEIN_PER_MG = 0.20  # $/mg for lutein

# --- New Constant for Lutein Yield Calculation ---
THEORETICAL_LUTEIN_PER_BIOMASS = 0.00556 # g Lu / 1 g Biomass

# --- Global Variables for ODE solver ---
C_x0_model, C_N0_model, F_in_model, C_N_in_model, I0_model = 0.5, 1.0, 8e-3, 10.0, 150.0
TIME_HOURS = 150 # Make it global and user-adjustable

# --- Global state for the interactive experiment ---
optimization_history = [] # Stores all evaluated points [x_params, y_value]
optimizer = None # The scikit-optimize Optimizer object
previewed_point = None # Stores the point from the "Preview" action
optimization_mode = "concentration"  # "concentration", "cost", or "yield"

# --- 2. Define the Photobioreactor ODE Model ---
def pbr(t, C):
    """Defines the system of Ordinary Differential Equations for the photobioreactor."""
    C_X, C_N, C_L = C
    if C_X < 1e-9: C_X = 1e-9
    if C_N < 1e-9: C_N = 1e-9
    if C_L < 1e-9: C_L = 1e-9

    I = 2 * I0_model * (np.exp(-(TAU * 0.01 * 1000 * C_X)))
    Iscaling_u = I / (I + K_S + I ** 2 / K_I)
    Iscaling_k = I / (I + K_SL + I ** 2 / K_IL)
    u0 = U_M * Iscaling_u
    k0 = K_M * Iscaling_k

    dCxdt = u0 * C_N * C_X / (C_N + K_N) - U_D * C_X
    dCndt = -Y_NX * u0 * C_N * C_X / (C_N + K_N) + F_in_model * C_N_in_model
    dCldt = k0 * C_N * C_X / (C_N + K_NL) - K_D * C_L * C_X
    return np.array([dCxdt, dCndt, dCldt])

# --- 3. Updated Cost Calculation Functions ---
def calculate_biomass_cost(C_x0):
    """Calculate biomass cost based on initial concentration"""
    return C_x0 * VOLUME_L * PRICE_BIOMASS_PER_G

def calculate_nitrogen_cost(C_N0, C_N_in, F_in, time_hours):
    """Calculate nitrogen cost based on initial and feed concentrations"""
    initial_cost = C_N0 * VOLUME_L * PRICE_NITROGEN_PER_G
    feed_cost = F_in * C_N_in * time_hours * PRICE_NITROGEN_PER_G
    return initial_cost + feed_cost

def calculate_energy_cost(I0, time_hours):
    """Calculate energy cost for lighting"""
    # Convert I0 from umol/m2-s to mol/m2-s
    I0_mol = I0 * 1e-6
    # Calculate energy required in Joules: mol/s / (mol/J) = J/s
    energy_J_per_s = I0_mol * AREA_M2 / EFFICIENCY
    # Convert to kWh: J/s * (3600 s/h) / (3.6e6 J/kWh) = kWh/h
    energy_kWh_per_h = energy_J_per_s * 3600 / 3.6e6
    # Total energy cost
    return energy_kWh_per_h * time_hours * PRICE_ENERGY_PER_KWH

def calculate_lutein_profit(lutein_concentration):
    """Calculate profit from lutein production"""
    lutein_mg_per_L = lutein_concentration * 1000  # g/L to mg/L
    return lutein_mg_per_L * VOLUME_L * PRICE_LUTEIN_PER_MG

def calculate_total_cost_and_profit(params, lutein_concentration, time_hours):
    """Calculate total cost, profit, and revenue (J)"""
    C_x0, C_N0, F_in, C_N_in, I0 = params
    
    biomass_cost = calculate_biomass_cost(C_x0)
    nitrogen_cost = calculate_nitrogen_cost(C_N0, C_N_in, F_in, time_hours)
    energy_cost = calculate_energy_cost(I0, time_hours)
    total_cost = biomass_cost + nitrogen_cost + energy_cost
    
    lutein_profit = calculate_lutein_profit(lutein_concentration)
    
    J = total_cost - lutein_profit
    
    return {
        'biomass_cost': biomass_cost,
        'nitrogen_cost': nitrogen_cost,
        'energy_cost': energy_cost,
        'total_cost': total_cost,
        'lutein_profit': lutein_profit,
        'revenue_J': J
    }

# --- New Yield Calculation Function ---
def calculate_lutein_yield(C_x_final, C_L_final):
    """Calculate the yield of lutein."""
    total_lutein_concentration_at_end = C_x_final + C_L_final
    theoretical_lutein_concentration = THEORETICAL_LUTEIN_PER_BIOMASS * total_lutein_concentration_at_end
    
    if theoretical_lutein_concentration <= 0: return 0.0
    
    yield_percent = (C_L_final / theoretical_lutein_concentration) * 100
    return yield_percent

# --- 4. Helper function to evaluate the model and objective ---
def _evaluate_lutein_model_objective(*args):
    """Sets up and runs a single simulation to find the final lutein concentration."""
    global C_x0_model, C_N0_model, F_in_model, C_N_in_model, I0_model, optimization_mode, TIME_HOURS
    C_x0_model, C_N0_model, F_in_model, C_N_in_model, I0_model = args
    
    sol = solve_ivp(pbr, [0, TIME_HOURS], [C_x0_model, C_N0_model, 0.0], t_eval=[TIME_HOURS], method="RK45")
    final_lutein = sol.y[2, -1]
    final_biomass = sol.y[0, -1]

    if not np.isfinite(final_lutein) or final_lutein <= 0:
        return 1e6
    
    if optimization_mode == "concentration":
        return -final_lutein
    elif optimization_mode == "cost":
        cost_analysis = calculate_total_cost_and_profit(args, final_lutein, TIME_HOURS)
        return cost_analysis['revenue_J']
    else: # optimization_mode == "yield"
        lutein_yield = calculate_lutein_yield(final_biomass, final_lutein)
        return -lutein_yield

# --- Data Sources ---
convergence_source = ColumnDataSource(data=dict(iter=[], best_value=[]))
simulation_source = ColumnDataSource(data=dict(time=[], C_X=[], C_N=[], C_L=[], C_L_scaled=[]))
experiments_source = ColumnDataSource(data=dict(
    C_x0=[], C_N0=[], F_in=[], C_N_in=[], I0=[], 
    Lutein=[], Total_Cost=[], Lutein_Profit=[], Revenue_J=[],
    Lutein_Yield=[], Biomass_Cost=[], Nitrogen_Cost=[], Energy_Cost=[]
))

# --- UI and Workflow Functions (these functions will rely on global doc) ---
def set_optimization_mode():
    """Update optimization mode based on user selection and toggle cost/yield visibility."""
    global optimization_mode, optimizer, TIME_HOURS
    new_mode = objective_select.value
    
    if new_mode == optimization_mode and optimizer is not None:
        return 
    
    optimization_mode = new_mode
    optimizer = None

    if optimization_mode == "concentration":
        p_conv.title.text = "Optimizer Convergence - Lutein Concentration"
        p_conv.yaxis.axis_label = "Max Lutein Found (g/L)"
        for col in cost_columns: col.visible = False
        for col in yield_columns: col.visible = False
        time_hours_input.visible = False
    elif optimization_mode == "cost":
        p_conv.title.text = "Optimizer Convergence - Revenue Optimization"
        p_conv.yaxis.axis_label = "Best Revenue (Profit - Cost) [$]"
        for col in cost_columns: col.visible = True
        for col in yield_columns: col.visible = False
        time_hours_input.visible = True
    else: # optimization_mode == "yield"
        p_conv.title.text = "Optimizer Convergence - Lutein Yield Optimization"
        p_conv.yaxis.axis_label = "Best Lutein Yield (%)"
        for col in cost_columns: col.visible = False
        for col in yield_columns: col.visible = True
        time_hours_input.visible = False
    
    # Update global TIME_HOURS from spinner value when switching to cost mode, or keep default
    TIME_HOURS = time_hours_input.value

    if not experiments_source.data['C_x0']:
        update_status("🟢 Ready. Select objective and define parameters, then generate initial points.")
    else:
        process_and_plot_latest_results() 
        update_status(f"Objective changed to '{optimization_mode}'. Recalculated best results.")
    
    set_ui_state()


def set_ui_state(lock_all=False):
    """Central function to manage the enabled/disabled state of all buttons and inputs."""
    if lock_all:
        for w in all_buttons: w.disabled = True
        for w in param_and_settings_widgets: w.disabled = True
        time_hours_input.disabled = True # Lock time_hours_input too
        return

    has_points = len(experiments_source.data['C_x0']) > 0
    has_uncalculated_points = has_points and any(np.isnan(v) for v in experiments_source.data['Lutein'])
    has_calculated_points = has_points and not has_uncalculated_points
    is_preview_pending = previewed_point is not None

    for widget in param_and_settings_widgets: 
        widget.disabled = has_points 
    
    # Only enable time_hours_input if in cost optimization mode AND no points generated yet
    time_hours_input.disabled = not (optimization_mode == "cost" and not has_points)

    generate_button.disabled = has_points
    calculate_button.disabled = not has_uncalculated_points
    suggest_button.disabled = not has_calculated_points or is_preview_pending
    run_suggestion_button.disabled = not is_preview_pending
    reset_button.disabled = not has_points

def get_current_dimensions():
    """Reads parameter ranges from UI and creates skopt dimension objects."""
    try:
        return [
            Real(cx0_range.value[0], cx0_range.value[1], name="C_x0"),
            Real(cn0_range.value[0], cn0_range.value[1], name="C_N0"),
            Real(fin_range.value[0], fin_range.value[1], name="F_in", prior='log-uniform'),
            Real(cnin_range.value[0], cnin_range.value[1], name="C_N_in"),
            Real(i0_range.value[0], i0_range.value[1], name="I0"),
        ]
    except Exception as e:
        update_status(f"❌ Error creating dimensions: {e}")
        return None

def reset_experiment():
    """Resets the entire application state to the beginning."""
    global optimization_history, optimizer, previewed_point, TIME_HOURS
    optimization_history.clear()
    optimizer = None
    previewed_point = None

    experiments_source.data = {k: [] for k in experiments_source.data}
    convergence_source.data = {k: [] for k in convergence_source.data}
    simulation_source.data = {k: [] for k in simulation_source.data}
    
    suggestion_div.text = ""
    results_div.text = ""

    # Reset TIME_HOURS spinner and global variable
    time_hours_input.value = 150
    TIME_HOURS = 150

    cx0, cn0 = cx0_range.value[1], cn0_range.value[1]
    cx_max, cn_max = cx0_range.end, cn0_range.end
    green_opacity = min((cx0 / cx_max) * 0.8, 0.8)
    blue_opacity = min((cn0 / cn_max) * 0.6, 0.6)
    green_gradient = f"linear-gradient(rgba(48, 128, 64, {green_opacity}), rgba(24, 64, 32, {green_opacity}))"
    blue_gradient = f"linear-gradient(rgba(52, 152, 219, {blue_opacity}), rgba(41, 128, 185, {blue_opacity}))"
    liquid_css = f"""
        position: absolute; bottom: 0; left: 0; right: 0; height: 95%;
        background: {green_gradient}, {blue_gradient};
        border-bottom-left-radius: 18px; border-bottom-right-radius: 18px; z-index: -1;
    """
    spacer.text = f'<div style="{liquid_css}"></div>'

    update_status("🟢 Ready. Define parameters and generate initial points.")
    set_optimization_mode() # This will handle visibility of time_hours_input
    set_ui_state()

def generate_initial_points():
    """Generates initial experimental points based on UI settings."""
    doc.add_next_tick_callback(lambda: update_status("🔄 Generating initial points..."))
    doc.add_next_tick_callback(lambda: set_ui_state(lock_all=True))
    
    def worker():
        dims = get_current_dimensions()
        if dims is None: 
            doc.add_next_tick_callback(set_ui_state)
            return

        n_initial = n_initial_input.value
        sampler_choice = sampler_select.value
        
        try:
            if sampler_choice == 'LHS':
                sampler = Lhs(lhs_type="centered", criterion="maximin")
                x0 = sampler.generate(dims, n_samples=n_initial)
            elif sampler_choice == 'Sobol':
                sampler = Sobol()
                x0 = sampler.generate(dims, n_samples=n_initial, random_state=np.random.randint(1000))
            else: # Random
                x0 = [ [d.rvs(1)[0] for d in dims] for _ in range(n_initial) ]

            new_data = {name.name: [point[i] for point in x0] for i, name in enumerate(dims)}
            new_data.update({
                'Lutein': [np.nan] * n_initial,
                'Total_Cost': [np.nan] * n_initial,
                'Lutein_Profit': [np.nan] * n_initial,
                'Revenue_J': [np.nan] * n_initial,
                'Lutein_Yield': [np.nan] * n_initial,
                'Biomass_Cost': [np.nan] * n_initial,
                'Nitrogen_Cost': [np.nan] * n_initial,
                'Energy_Cost': [np.nan] * n_initial
            })
            
            def callback():
                experiments_source.data = new_data
                update_status("🟢 Generated initial points. Ready to calculate.")
                set_ui_state()
            doc.add_next_tick_callback(callback)

        except Exception as e:
            doc.add_next_tick_callback(lambda: update_status(f"❌ Error generating points: {e}"))
            doc.add_next_tick_callback(set_ui_state)

    threading.Thread(target=worker).start()


def calculate_lutein_for_table():
    """Runs simulation for the points in the table."""
    doc.add_next_tick_callback(lambda: update_status("🔄 Calculating Lutein and costs for initial points..."))
    doc.add_next_tick_callback(lambda: set_ui_state(lock_all=True))

    def worker():
        try:
            nan_indices = [i for i, v in enumerate(experiments_source.data['Lutein']) if np.isnan(v)]
            if not nan_indices:
                doc.add_next_tick_callback(lambda: update_status("🟢 All points already calculated."))
                doc.add_next_tick_callback(set_ui_state)
                return
                
            points_to_calc = []
            for i in nan_indices: 
                points_to_calc.append([experiments_source.data[name][i] for name in ['C_x0', 'C_N0', 'F_in', 'C_N_in', 'I0']])

            results = []
            for i, p in enumerate(points_to_calc):
                doc.add_next_tick_callback(lambda i=i: update_status(f"🔄 Calculating point {i+1}/{len(points_to_calc)}..."))
                
                global C_x0_model, C_N0_model, F_in_model, C_N_in_model, I0_model, TIME_HOURS
                temp_Cx0, temp_CN0, temp_Fin, temp_CNin, temp_I0 = C_x0_model, C_N0_model, F_in_model, C_N_in_model, I0_model
                C_x0_model, C_N0_model, F_in_model, C_N_in_model, I0_model = p
                sol = solve_ivp(pbr, [0, TIME_HOURS], [p[0], p[1], 0.0], t_eval=[TIME_HOURS], method="RK45")
                C_x0_model, C_N0_model, F_in_model, C_N_in_model, I0_model = temp_Cx0, temp_CN0, temp_Fin, temp_CNin, temp_I0

                lutein_conc = sol.y[2, -1]
                biomass_conc = sol.y[0, -1]

                obj_val = _evaluate_lutein_model_objective(*p)
                
                cost_analysis = calculate_total_cost_and_profit(p, lutein_conc, TIME_HOURS)
                lutein_yield = calculate_lutein_yield(biomass_conc, lutein_conc)
                
                results.append({
                    'lutein': lutein_conc,
                    'total_cost': cost_analysis['total_cost'],
                    'lutein_profit': cost_analysis['lutein_profit'],
                    'revenue_j': cost_analysis['revenue_J'],
                    'lutein_yield': lutein_yield,
                    'biomass_cost': cost_analysis['biomass_cost'],
                    'nitrogen_cost': cost_analysis['nitrogen_cost'],
                    'energy_cost': cost_analysis['energy_cost']
                })
                
                if not any(np.array_equal(p, item[0]) for item in optimization_history):
                    optimization_history.append([p, obj_val])

            def callback():
                current_data = experiments_source.data.copy()
                for i, res_idx in enumerate(nan_indices):
                    current_data['Lutein'][res_idx] = results[i]['lutein']
                    current_data['Total_Cost'][res_idx] = results[i]['total_cost']
                    current_data['Lutein_Profit'][res_idx] = results[i]['lutein_profit']
                    current_data['Revenue_J'][res_idx] = results[i]['revenue_j']
                    current_data['Lutein_Yield'][res_idx] = results[i]['lutein_yield']
                    current_data['Biomass_Cost'][res_idx] = results[i]['biomass_cost']
                    current_data['Nitrogen_Cost'][res_idx] = results[i]['nitrogen_cost']
                    current_data['Energy_Cost'][res_idx] = results[i]['energy_cost']
                
                experiments_source.data = current_data
                update_status("✅ Calculation complete. Ready to get a suggestion.")
                process_and_plot_latest_results()
                set_ui_state()
            doc.add_next_tick_callback(callback)
            
        except Exception as e:
            error_message = f"❌ Error during calculation: {e}"
            doc.add_next_tick_callback(lambda: update_status(error_message))
            doc.add_next_tick_callback(set_ui_state)

    threading.Thread(target=worker).start()

def _ensure_optimizer_is_ready():
    """Internal helper to create and prime the optimizer if it doesn't exist."""
    global optimizer
    if optimizer is None:
        dims = get_current_dimensions()
        x_history = [item[0] for item in optimization_history]
        y_history = [item[1] for item in optimization_history]
        
        optimizer = Optimizer(
            dimensions=dims,
            base_estimator=surrogate_select.value,
            acq_func=acq_func_select.value,
            n_initial_points=len(x_history), 
            random_state=np.random.randint(1000)
        )
        
        if x_history:
            optimizer.tell(x_history, y_history)

def suggest_next_experiment():
    """Asks the optimizer for the next best point to sample, without running it."""
    global previewed_point
    doc.add_next_tick_callback(lambda: update_status("🔄 Getting next suggestion preview..."))
    doc.add_next_tick_callback(lambda: set_ui_state(lock_all=True))

    def worker():
        global previewed_point
        try:
            _ensure_optimizer_is_ready()
            next_point = optimizer.ask()
            previewed_point = next_point
            mean, std = optimizer.models[-1].predict([next_point], return_std=True)
            
            metric_text = ""
            if optimization_mode == "concentration":
                predicted_lutein = -mean[0]
                uncertainty = std[0]
                metric_text = f"<b>Predicted Lutein: {predicted_lutein:.4f} ± {uncertainty:.4f} g/L</b>"
            elif optimization_mode == "cost":
                predicted_revenue = mean[0]
                uncertainty = std[0]
                metric_text = f"<b>Predicted Revenue (J): ${predicted_revenue:.4f} ± {uncertainty:.4f}</b>"
            else: # optimization_mode == "yield"
                predicted_yield = -mean[0]
                uncertainty = std[0]
                metric_text = f"<b>Predicted Lutein Yield: {predicted_yield:.4f} ± {uncertainty:.4f} %</b>"

            def callback():
                names = [d.name for d in get_current_dimensions()]
                suggestion_html = "<h5>Suggested Next Experiment:</h5>"
                suggestion_html += metric_text + "<ul>"
                for name, val in zip(names, next_point):
                    suggestion_html += f"<li><b>{name}:</b> {val:.4f}</li>"
                suggestion_html += "</ul>"
                suggestion_div.text = suggestion_html
                update_status("💡 Suggestion received. You can now run this specific experiment.")
                set_ui_state()
            doc.add_next_tick_callback(callback)
        except Exception as e:
            error_message = f"❌ Error getting preview: {e}"
            doc.add_next_tick_callback(lambda: update_status(error_message))
            doc.add_next_tick_callback(set_ui_state)
    threading.Thread(target=worker).start()
    
def run_suggestion():
    """Runs the specific experiment that was previewed."""
    if previewed_point is None: return
    doc.add_next_tick_callback(lambda: update_status("🔄 Running suggested experiment..."))
    doc.add_next_tick_callback(lambda: set_ui_state(lock_all=True))

    def worker():
        global previewed_point, TIME_HOURS
        try:
            point_to_run = previewed_point
            obj_val = _evaluate_lutein_model_objective(*point_to_run)
            
            global C_x0_model, C_N0_model, F_in_model, C_N_in_model, I0_model
            temp_Cx0, temp_CN0, temp_Fin, temp_CNin, temp_I0 = C_x0_model, C_N0_model, F_in_model, C_N_in_model, I0_model
            C_x0_model, C_N0_model, F_in_model, C_N_in_model, I0_model = point_to_run
            sol = solve_ivp(pbr, [0, TIME_HOURS], [point_to_run[0], point_to_run[1], 0.0], t_eval=[TIME_HOURS], method="RK45")
            C_x0_model, C_N0_model, F_in_model, C_N_in_model, I0_model = temp_Cx0, temp_CN0, temp_Fin, temp_CNin, temp_I0
            lutein_val = sol.y[2, -1]
            biomass_val = sol.y[0, -1]
            cost_analysis = calculate_total_cost_and_profit(point_to_run, lutein_val, TIME_HOURS)
            lutein_yield_val = calculate_lutein_yield(biomass_val, lutein_val)
            
            optimizer.tell(point_to_run, obj_val)
            optimization_history.append([point_to_run, obj_val])
            
            def callback():
                global previewed_point
                new_point_data = {
                    'C_x0': [point_to_run[0]],
                    'C_N0': [point_to_run[1]],
                    'F_in': [point_to_run[2]],
                    'C_N_in': [point_to_run[3]],
                    'I0': [point_to_run[4]],
                    'Lutein': [lutein_val],
                    'Total_Cost': [cost_analysis['total_cost']],
                    'Lutein_Profit': [cost_analysis['lutein_profit']],
                    'Revenue_J': [cost_analysis['revenue_j']],
                    'Lutein_Yield': [lutein_yield_val],
                    'Biomass_Cost': [cost_analysis['biomass_cost']],
                    'Nitrogen_Cost': [cost_analysis['nitrogen_cost']],
                    'Energy_Cost': [cost_analysis['energy_cost']]
                }
                experiments_source.stream(new_point_data)
                opt_step_number = len(optimization_history) - n_initial_input.value
                
                if optimization_mode == "concentration":
                    update_status(f"✅ Ran suggested experiment as Step {opt_step_number}. Lutein: {lutein_val:.4f} g/L")
                elif optimization_mode == "cost":
                    update_status(f"✅ Ran suggested experiment as Step {opt_step_number}. Revenue: ${cost_analysis['revenue_J']:.4f}")
                else: # optimization_mode == "yield"
                    update_status(f"✅ Ran suggested experiment as Step {opt_step_number}. Lutein Yield: {lutein_yield_val:.4f} %")
                
                previewed_point = None
                suggestion_div.text = ""
                process_and_plot_latest_results()
                set_ui_state()
            doc.add_next_tick_callback(callback)
        except Exception as e:
            error_message = f"❌ Error running suggestion: {e}"
            doc.add_next_tick_callback(lambda: update_status(error_message))
            doc.add_next_tick_callback(set_ui_state)

    threading.Thread(target=worker).start()

def process_and_plot_latest_results():
    """Finds the best result from the history and updates plots."""
    if not optimization_history: 
        results_div.text = ""
        return
    
    best_item = min(optimization_history, key=lambda item: item[1])
    best_params, best_obj_val = best_item[0], best_item[1]
    
    global C_x0_model, C_N0_model, F_in_model, C_N_in_model, I0_model, TIME_HOURS
    temp_Cx0, temp_CN0, temp_Fin, temp_CNin, temp_I0 = C_x0_model, C_N0_model, F_in_model, C_N_in_model, I0_model
    C_x0_model, C_N0_model, F_in_model, C_N_in_model, I0_model = best_params
    sol = run_final_simulation(best_params)
    C_x0_model, C_N0_model, F_in_model, C_N_in_model, I0_model = temp_Cx0, temp_CN0, temp_Fin, temp_CNin, temp_I0
    
    max_lutein = sol.y[2, -1]
    final_biomass = sol.y[0, -1]
    final_nitrate = sol.y[1, -1]
    cost_analysis = calculate_total_cost_and_profit(best_params, max_lutein, TIME_HOURS)
    best_yield = calculate_lutein_yield(final_biomass, max_lutein)
    
    optimal_params = {dim.name: val for dim, val in zip(get_current_dimensions(), best_params)}

    results_html = f"<h3>Overall Best Result So Far</h3>"
    if optimization_mode == "concentration":
        results_html += f"<b>Maximum Lutein Found:</b> {max_lutein:.4f} g/L<br/>"
    elif optimization_mode == "cost":
        results_html += f"<b>Best Revenue (J):</b> ${cost_analysis['revenue_J']:.4f}<br/>"
        results_html += f"<b>Lutein Concentration:</b> {max_lutein:.4f} g/L<br/>"
        results_html += f"<b>Total Cost:</b> ${cost_analysis['total_cost']:.4f}<br/>"
        results_html += f"<b>Biomass Cost:</b> ${cost_analysis['biomass_cost']:.4f}<br/>"
        results_html += f"<b>Nitrogen Cost:</b> ${cost_analysis['nitrogen_cost']:.4f}<br/>"
        results_html += f"<b>Energy Cost:</b> ${cost_analysis['energy_cost']:.4f}<br/>"
        results_html += f"<b>Lutein Profit:</b> ${cost_analysis['lutein_profit']:.4f}<br/>"
    else: # yield optimization
        results_html += f"<b>Maximum Lutein Yield Found:</b> {best_yield:.4f} %<br/>"
        results_html += f"<b>Lutein Concentration:</b> {max_lutein:.4f} g/L<br/>"
        results_html += f"<b>Total Cost:</b> ${cost_analysis['total_cost']:.4f}<br/>"
        results_html += f"<b>Lutein Profit:</b> ${cost_analysis['lutein_profit']:.4f}<br/>"
    
    results_html += "<b>Corresponding Parameters:</b><ul>"
    for param, value in optimal_params.items(): 
        results_html += f"<li><b>{param}:</b> {value:.4f}</li>"
    results_html += "</ul>"
    results_div.text = results_html

    spacer.styles = GLASS_STYLE
    orange_opacity = np.clip(max_lutein / 0.018, 0.0, 1.0) * 0.9
    orange_gradient = f"linear-gradient(rgba(255, 140, 0, {orange_opacity}), rgba(210, 105, 30, {orange_opacity}))"
    green_opacity = np.clip(final_biomass / 5.0, 0.0, 1.0) * 0.6
    green_gradient = f"linear-gradient(rgba(48, 128, 64, {green_opacity}), rgba(24, 64, 32, {green_opacity}))"
    blue_opacity = np.clip(final_nitrate / 2.0, 0.0, 1.0) * 0.5
    blue_gradient = f"linear-gradient(rgba(52, 152, 219, {blue_opacity}), rgba(41, 128, 185, {blue_opacity}))"
    liquid_css = f"""
        position: absolute; bottom: 0; left: 0; right: 0; height: 95%;
        background: {orange_gradient}, {green_gradient}, {blue_gradient};
        border-bottom-left-radius: 18px; border-bottom-right-radius: 18px; z-index: -1;
    """
    spacer.text = f'<div style="{liquid_css}"></div>'
    
    update_convergence_plot_from_history()

def update_convergence_plot_from_history():
    """Recalculates and updates the entire convergence plot from the history."""
    num_initial = n_initial_input.value
    opt_history = optimization_history[num_initial:]
    if not opt_history:
        convergence_source.data = dict(iter=[], best_value=[])
        return
        
    iters = list(range(1, len(opt_history) + 1))
    best_values_so_far = []
    
    initial_points_history = optimization_history[:num_initial]
    
    current_best_initial = None
    if initial_points_history:
        if optimization_mode == "concentration" or optimization_mode == "yield":
            current_best_initial = -min(p[1] for p in initial_points_history) 
        else: # cost optimization
            current_best_initial = min(p[1] for p in initial_points_history)

    current_best = current_best_initial if current_best_initial is not None else (-np.inf if optimization_mode in ["concentration", "yield"] else np.inf)

    for _, y_val in opt_history:
        if optimization_mode == "concentration" or optimization_mode == "yield":
            value = -y_val
            if value > current_best: current_best = value
        else: # cost optimization
            value = y_val
            if value < current_best: current_best = value
        best_values_so_far.append(current_best)
        
    convergence_source.data = {'iter': iters, 'best_value': best_values_so_far}
    p_conv.xaxis.ticker = FixedTicker(ticks=iters)
    if iters:
        p_conv.x_range.end = iters[-1] + 0.5

def run_final_simulation(best_params):
    """Runs and plots a full simulation using the provided parameter set."""
    global C_x0_model, C_N0_model, F_in_model, C_N_in_model, I0_model, TIME_HOURS
    temp_Cx0, temp_CN0, temp_Fin, temp_CNin, temp_I0 = C_x0_model, C_N0_model, F_in_model, C_N_in_model, I0_model
    C_x0_model, C_N0_model, F_in_model, C_N_in_model, I0_model = best_params
    
    t_eval = np.linspace(0, TIME_HOURS, 300)
    initial_conditions = [best_params[0], best_params[1], 0.0]
    sol = solve_ivp(pbr, [0, TIME_HOURS], initial_conditions, t_eval=t_eval, method="RK45")
    
    C_x0_model, C_N0_model, F_in_model, C_N_in_model, I0_model = temp_Cx0, temp_CN0, temp_Fin, temp_CNin, temp_I0
    simulation_source.data = {
        "time": sol.t, 
        "C_X": np.maximum(0, sol.y[0]), 
        "C_N": np.maximum(0, sol.y[1]), 
        "C_L": np.maximum(0, sol.y[2]), 
        "C_L_scaled": np.maximum(0, sol.y[2]) * 100
    }
    return sol

def update_status(message): 
    status_div.text = message

def update_time_hours(attr, old, new):
    """Updates the global TIME_HOURS variable when the spinner changes."""
    global TIME_HOURS
    TIME_HOURS = new
    update_status(f"Simulation time set to {TIME_HOURS} hours.")


# --- UI Widgets ---
title_div = Div(text="<h1>Lutein Production Bayesian Optimizer with Cost Analysis</h1>")
description_p = Paragraph(text="""This application uses Bayesian Optimization to find optimal operating conditions for a photobioreactor. You can optimize for maximum lutein concentration, minimum cost, or maximum yield. Follow the steps to run a virtual experiment.""", width=450)

objective_title = Div(text="<h4>0. Select Optimization Objective</h4>")
objective_select = Select(title="Optimization Objective:", value="concentration", 
                          options=[("concentration", "Maximize Lutein Concentration"), 
                                   ("cost", "Minimize Cost (Maximize Revenue)"),
                                   ("yield", "Maximize Lutein Yield")])
objective_select.on_change('value', lambda attr, old, new: set_optimization_mode())

# New Spinner for TIME_HOURS
time_hours_input = Spinner(title="Simulation Time (Hours):", low=1, step=1, value=TIME_HOURS, width=150, visible=False)
time_hours_input.on_change('value', update_time_hours)


param_range_title = Div(text="<h4>1. Define Parameter Search Space</h4>")
cx0_range = RangeSlider(title="C_x0 Range (g/L)", start=0, end=10, value=(0.2, 2.0), step=0.1)
cn0_range = RangeSlider(title="C_N0 Range (g/L)", start=0, end=10, value=(0.2, 2.0), step=0.1) 
fin_range = RangeSlider(title="F_in Range", start=1e-5, end=1.5e-1, value=(1e-3, 1.5e-2), step=1e-4, format="0.0000")
cnin_range = RangeSlider(title="C_N_in Range (g/L)", start=0, end=50, value=(5.0, 15.0), step=0.5)
i0_range = RangeSlider(title="I0 Range (umol/m2-s)", start=0, end=1000, value=(100, 200), step=10)

# Photobioreactor Visualization UI
indicator_panel_title = Div(text="<h4>Photobioreactor State</h4>")
lights = [Div(text="<p>...</p>", width=60, height=60, styles={'text-align': 'center'}) for _ in range(6)]

color_change_callback = CustomJS(
    args=dict(slider=i0_range, l1=lights[0], l2=lights[1], l3=lights[2], l4=lights[3], l5=lights[4], l6=lights[5]),
    code="""
    const i0_value = slider.value[1];
    let new_color = 'grey';
    if (i0_value < 100) { new_color = '#4D4C00'; } else if (i0_value < 200) { new_color = '#807E00'; }
    else if (i0_value < 300) { new_color = '#B3B000'; } else if (i0_value < 400) { new_color = '#E6E200'; }
    else if (i0_value < 500) { new_color = '#FFFF00'; } else if (i0_value < 600) { new_color = '#FFFF33'; }
    else if (i0_value < 700) { new_color = '#FFFF66'; } else if (i0_value < 800) { new_color = '#FFFF99'; }
    else if (i0_value < 900) { new_color = '#FFFFCC'; } else { new_color = '#FFFFF0'; }
    const new_html = `<svg height="50" width="50"><circle cx="25" cy="25" r="20" stroke="black" stroke-width="2" fill="${new_color}" /></svg>`;
    const all_lights = [l1, l2, l3, l4, l5, l6];
    all_lights.forEach(light => { light.text = new_html; });
""")
i0_range.js_on_change('value', color_change_callback)

spacer = Div(text="", width=200, height=200)
update_initial_liquid_callback = CustomJS(args=dict(cx_slider=cx0_range, cn_slider=cn0_range, liquid_div=spacer), code="""
    const cx0 = cx_slider.value[1];
    const cn0 = cn_slider.value[1];
    const cx_max = cx_slider.end;
    const cn_max = cn_slider.end;
    const green_opacity = Math.min((cx0 / cx_max) * 0.8, 0.8);
    const blue_opacity = Math.min((cn0 / cn_max) * 0.6, 0.6);
    const green_gradient = `linear-gradient(rgba(48, 128, 64, ${green_opacity}), rgba(24, 64, 32, ${green_opacity}))`;
    const blue_gradient = `linear-gradient(rgba(52, 152, 219, ${blue_opacity}), rgba(41, 128, 185, ${blue_opacity}))`;
    const liquid_css = `
        position: absolute; bottom: 0; left: 0; right: 0; height: 95%;
        background: ${green_gradient}, ${blue_gradient};
        border-bottom-left-radius: 18px; border-bottom-right-radius: 18px; z-index: -1;
    `;
    liquid_div.text = `<div style="${liquid_css}"></div>`;
""")
cx0_range.js_on_change('value', update_initial_liquid_callback)
cn0_range.js_on_change('value', update_initial_liquid_callback)
doc.js_on_event('document_ready', color_change_callback, update_initial_liquid_callback)

settings_title = Div(text="<h4>2. Configure Initial Sampling & Model</h4>")
surrogate_select = Select(title="Surrogate Model:", value="GP", options=["GP", "RF", "ET"])
acq_func_select = Select(title="Acquisition Function:", value="gp_hedge", options=["EI", "PI", "LCB", "gp_hedge"])
sampler_select = Select(title="Sampling Method:", value="LHS", options=["LHS", "Sobol", "Random"])
n_initial_input = Spinner(title="Number of Initial Points:", low=1, step=1, value=10, width=150)
param_and_settings_widgets = [objective_select, cx0_range, cn0_range, fin_range, cnin_range, i0_range, surrogate_select, acq_func_select, sampler_select, n_initial_input]

actions_title = Div(text="<h4>3. Run Experiment Workflow</h4>")
generate_button = Button(label="A) Generate Initial Points", button_type="primary", width=400)
calculate_button = Button(label="B) Calculate Lutein & Costs for Initial Points", button_type="default", width=400)
suggest_button = Button(label="C) Suggest Next Experiment & Show Prediction", button_type="success", width=400)
suggestion_div = Div(text="", width=400)
run_suggestion_button = Button(label="D) Run Suggested Experiment & Update Model", button_type="warning", width=400)
reset_button = Button(label="Reset Experiment", button_type="danger", width=400)
all_buttons = [generate_button, calculate_button, suggest_button, run_suggestion_button, reset_button]

generate_button.on_click(generate_initial_points)
calculate_button.on_click(calculate_lutein_for_table)
suggest_button.on_click(suggest_next_experiment)
run_suggestion_button.on_click(run_suggestion)
reset_button.on_click(reset_experiment)

status_div = Div(text="🟢 Ready. Select objective and define parameters, then generate initial points.")
results_div = Div(text="")

# --- Data Table & Plots ---
columns = [
    TableColumn(field="C_x0", title="C_x0", formatter=NumberFormatter(format="0.0000")),
    TableColumn(field="C_N0", title="C_N0", formatter=NumberFormatter(format="0.0000")),
    TableColumn(field="F_in", title="F_in", formatter=NumberFormatter(format="0.0000")),
    TableColumn(field="C_N_in", title="C_N_in", formatter=NumberFormatter(format="0.0000")),
    TableColumn(field="I0", title="I0", formatter=NumberFormatter(format="0.0000")),
    TableColumn(field="Lutein", title="Lutein (g/L)", formatter=NumberFormatter(format="0.0000")),
    TableColumn(field="Total_Cost", title="Total Cost ($)", formatter=NumberFormatter(format="0.0000")),
    TableColumn(field="Lutein_Profit", title="Lutein Profit ($)", formatter=NumberFormatter(format="0.0000")),
    TableColumn(field="Revenue_J", title="Revenue J ($)", formatter=NumberFormatter(format="0.0000")),
    TableColumn(field="Lutein_Yield", title="Lutein Yield (%)", formatter=NumberFormatter(format="0.0000")),
    TableColumn(field="Biomass_Cost", title="Biomass Cost ($)", formatter=NumberFormatter(format="0.0000")),
    TableColumn(field="Nitrogen_Cost", title="Nitrogen Cost ($)", formatter=NumberFormatter(format="0.0000")),
    TableColumn(field="Energy_Cost", title="Energy Cost ($)", formatter=NumberFormatter(format="0.0000"))
]

cost_columns = [col for col in columns if col.field in ['Total_Cost', 'Lutein_Profit', 'Revenue_J', 'Biomass_Cost', 'Nitrogen_Cost', 'Energy_Cost']]
yield_columns = [col for col in columns if col.field in ['Lutein_Yield']]

data_table = DataTable(source=experiments_source, columns=columns, width=1000, height=280, editable=False)

p_conv = figure(height=300, width=800, title="Optimizer Convergence", x_axis_label="Optimization Step", y_axis_label="Best Value", y_range=DataRange1d(start=0, range_padding=0.1, range_padding_units='percent'))
p_conv.xaxis.formatter = NumeralTickFormatter(format="0")
p_conv.line(x="iter", y="best_value", source=convergence_source, line_width=2)

p_sim = figure(height=300, width=800, title="Simulation with Best Parameters", x_axis_label="Time (hours)", y_axis_label="Biomass & Nitrate Conc. (g/L)", y_range=DataRange1d(start=0))
p_sim.extra_y_ranges = {"lutein_range": DataRange1d(start=0)}
p_sim.add_layout(LinearAxis(y_range_name="lutein_range", axis_label="Lutein Conc. (x100) [g/L]"), 'right')

p_sim.line(x="time", y="C_X", source=simulation_source, color="green", line_width=2, legend_label="Biomass (C_X)")
p_sim.line(x="time", y="C_N", source=simulation_source, color="blue", line_width=2, legend_label="Nitrate (C_N)")
p_sim.line(x="time", y="C_L_scaled", source=simulation_source, color="orange", line_width=3, legend_label="Lutein (C_L) x100", y_range_name="lutein_range")
p_sim.legend.location = "top_left"
p_sim.legend.click_policy = "hide"

# Photobioreactor visualization panel
GLASS_STYLE = {
    'border': '2px solid rgba(255, 255, 255, 0.4)', 'border-radius': '20px',
    'background': 'rgba(255, 255, 255, 0.15)', 'box-shadow': 'inset 0 2px 6px rgba(0, 0, 0, 0.1)',
    'position': 'relative', 'overflow': 'hidden', 'backdrop-filter': 'blur(3px)',
    '-webkit-backdrop-filter': 'blur(3px)', 'box-sizing': 'border-box'
}
spacer.styles = GLASS_STYLE
lamp_style = {
    'border': '2px solid rgba(85, 85, 85, 0.5)', 'border-radius': '15px',
    'background': 'linear-gradient(to right, rgba(136,136,136,0.5), rgba(211,211,211,0.5), rgba(136,136,136,0.5))',
    'padding': '15px 5px', 'box-sizing': 'border-box'
}
tube_div = Div(width=120, height=30, styles={'background': 'linear-gradient(to bottom, rgba(211,211,211,0.6), rgba(136,136,136,0.6))', 'border': '2px solid rgba(85, 85, 85, 0.6)', 'border-radius': '10px', 'margin': '0 auto -10px auto'})
vertical_tube_div = Div(width=25, height=60, styles={'background': 'linear-gradient(to right, rgba(136,136,136,0.6), rgba(211,211,211,0.6), rgba(136,136,136,0.6))', 'border': '2px solid rgba(85, 85, 85, 0.6)', 'border-top-left-radius': '8px', 'border-top-right-radius': '8px', 'margin': '0 auto -5px auto'})

left_light_col = column(lights[0], lights[1], lights[2], styles=lamp_style)
right_light_col = column(lights[3], lights[4], lights[5], styles=lamp_style)
center_column = column(vertical_tube_div, tube_div, spacer, styles={'gap': '0'})
indicator_panel = row(left_light_col, center_column, right_light_col, align='center')

# --- Layouts for Tabs ---

# "Jump to Module" button for the About page
# We'll need a reference to the main_tabs object, which will be available in CustomJS
jump_to_optimizer_button = Button(label="Jump to Module", button_type="primary", width=200, height=50)

# About Tab Content (previously the entire HTML body)
about_tab_content = layout(
    Div(text="""<h3>Welcome to Bayesian Optimization</h3>""" +
             """<div class="home_container">
                <div class="column_1_home">
                    <p>Ever wish there was a more efficent way to find an optimal set of conditions for your experiment? This module will guide you on how to be able to use Bayesian Optimization to be able to find optimal conditions for the highest yeild
                        using a few given data points.</p>

                    <p>Our module will be able to help teach about a specific machine learning topic even with NO coding experience. Now, you may be wondering, "What is machine learning?" Machine learning (ML) is subfield of Artificial Intelligence (AI)
                        that can learn from given data without having the explicit programming to do so. ML is used in the engineering, science, and business industries to solve complex problems that can not be easily defined by a model. In this module,
                        a photobioreactor example will be used to help demostrate the topic by predicting an optimal lutein, the product, concentration.</p>

                    <p>CLICK on the next tab to start learning!</p>
                </div>

                <div class="column_2_home">
                    <figure>
                        <img src="static/BO_Cycle.png" alt="Front page image" class="right" style="width:600px; height: 425px;">
                    </figure>
                </div>
            </div>"""
    ),
    Div(text="""<div class="row" style="justify-items: center; display: grid; padding: 30px 0 0 0; gap: 8px;">
                <p style="margin: 0;">
                    <b>NOTE:</b> If the module below is not appearing, try opening this page in a private/incognito window.
                </p>
                <br>
                <p style="margin: 0;">
                    Due to the size of the dataset, it may take a few seconds to load.
                </p>
                <br>
                </div>"""
    ),
    row(column(jump_to_optimizer_button), align='center') # Add the button here
)

# Photobioreactor Tab Content
photobioreactor_tab_content = layout(
    Div(text="""
        <div class="row">
            <div class="left-section">
                <div class="model-container" style="text-align: center;">
                    <h2>What is a Photobioreactor?</h2>
                    <p>A photobioreactor (PBR) is a reactor used to cultivate products from phototrophic organisms, using light as their main source of energy. PBRs are made of transparent materials such as plastics or glass to allow for this light growth.
                        Conditions such as temperature, CO<sub>2</sub>, pH, and nutrients can be easily controlled to keep a healthy environment for the organisms. The parameters of this reactor in this module can be found under the <i>Instructions</i> tab.</p>
                    <br>
                    <h2>About Lutein</h2>
                    <p>Our particular photobioreactor in this model is used to grow lutein. Lutein is a carotenoid which is a red-orange-yellow dye that is found primarily in marigolds. What makes lutein so special is that it can be used in medical treatments.
                        Common treatments are to help prevent cataracts in the human eyes and delay of cancers and macular degeneration. It also has common use in food dyes. However, marigolds are low in lutein content. This has led scientists to
                        try and find other sources of higher lutein content. The source of focus for this module will be microalgae which shows promise to be a more efficient way of extracting Lutein than marigolds. To produce lutein from microalgae,
                        nitrate is used as a nutrient and light is shined into the photobioreactor from either side. However, too much nitrate is not good for lutein production since microalgae produce more lutein under stress. Too much biomass is
                        also not good for lutein production as overcrowding can block the light source.</p>
                </div>
            </div>
            <div class="right-column-container">
                <div class="top-right-section">
                    <figure>
                        <img src="static/Photobioreactor.jpg" alt="PBR_image" class="columni-img">
                        <figcaption>Image Source: https://www.researchgate.net/figure/Schematic-representation-of-the-photobioreactor_fig1_259772693</figcaption>
                    </figure>
                </div>
                <div class="bottom-right-section">
                    <div class="model-container">
                        <h2>How can this be put to action?</h2>
                        <p style="text-align: center;">The main challenge faced when trying to make microalgea a feasible source of lutein is industrializing it. First off, the microalgae is very sensitive to high temperatures making it difficult to industrialize. The second part,
                            our focus in this module, is optimizing the lutein output. Scaling up is an expensive process, so it is important that the lutein is in high yield and cost efficient. The parameters of the experiemnt must be optimized in
                            order to help solve this industrialization challenge, but how do we find the optimal conditions when experiments are expensive to conduct? This is where Bayesian Optimization comes into play.</p>
                    </div>
                </div>
            </div>
        </div>
    """
    )
)

# BO Model Tab Content
bo_model_tab_content = layout(
    Div(text="""
        <div class="model-section">
            <div class="text-content">
                <h2>Basics of Bayesian Optimization</h2>
                <h3>What is it?</h3>
                <p>Bayesian Optimization (BO) is an optimization technique that uses expensive trials to quickly arrive at an optimum point in some unknown function. The functions are called
                    <span class="tooltip">
                    black box functions
                    <span class="tooltip-text">These are systems where the internal function is unknown.</span>
                    </span>.
                </p>
                <h3>Why use it?</h3>
                <p>Since these black box functions have no model, Bayesian Optimization is used to find these unknown optimal values. In the photobioreactor system, a few different conditions will be tested, varying the parameters of each one. This information
                    can be used for Bayesian Optimization to find a likely set of parameters for the optimal lutein extraction.</p>
                <h3>How does it work?</h3>
                <p>BO uses a combination of
                    <span class="tooltip">
                    exploration
                    <span class="tooltip-text">A prediction is made at an unknown set of parameters to find out more about the function.</span>
                    </span>
                    and
                    <span class="tooltip">
                    exploitation
                    <span class="tooltip-text">Information about known and predicted parameter sets are used to hone in on a possible optimum.</span>
                    </span>. If the parameter set, known or guessed, is considered far away from the optimum, it will not be considered, but if it is considered close to a theoretical optimum, guesses will be made closer to that parameter set. BO
                    is a coherent combination of an acquisition function and a surrogate model. Acquisition function can be thought of making an educated guess based off of the ground work a surrogate model has laid. The surrogate model effectively
                    creates a pseudo function for the acquisition function to guess within.</p>
            </div>
            <div class="image-container">
                <img src="static/iterationdata.png" alt="iteration data" class="model-img">
                <br><br>
                <img src="static/optimizaerconvergence.png" alt="optimizer convergence" class="model-img">
                <br><br>
                <img src="static/situationwithbestparameters.png" alt="situation with best parameters" class="model-img">
            </div>
        </div>
    """
    )
)

# Surrogate Model / Acquisition Function Tab Content
surrogate_acq_func_tab_content = layout(
    Div(text="""
        <div class="row">
            <div class="column">
                <div class="model-container">
                    <h2>Surrogate Model</h2>
                    <p>This is used together with the acquisition function to find the optimum set of parameters. The surrogate model’s part of the job is to create a function that encapsulates many possibilities for functions given the data set. Using
                        given data points the surrogate model can create a probabilistic function that is representative of the unknown real function. The surrogate model uses exploration and exploitation by creating a smaller confidence limit near
                        points of known data and creating a larger confidence limit in areas further away from known data points.</p>
                    <br>
                    <figure>
                        <img src="static/SurrogateModel.png" alt="Surrogate Model" style="width:450px; height:350px;" class="center model-img">
                        <figcaption style="text-align: center; margin-top: 8px; font-size: 0.9em; font-style: italic; color: #555;">
                            Image Source: https://neurocomputinglab.com/jobs/surrogate-modeling/
                        </figcaption>
                    </figure>
                </div>
            </div>
            <div class="column">
                <div class="model-container">
                    <h2>Acquisition Function</h2>
                    <p>On the other side of the coin, there is the acquisition function. This uses the surrogate model to make predictions of an optimal value. The way the acquisition function makes its predictions is through a balance of exploration
                            and exploitation. Predictions will be made in high areas of uncertainty, commonly areas far away from the original data set or previous predictions. The other way predictions are made is by checking areas with a high mean compared
                            to the original dataset and previously predicted points. A prediction that has a higher value compared to the mean will be considered more optimal.</p>
                    <figure>
                        <img src="static/AcquisitionFunction.png" alt="Acquisition Function" style="width:450px; height:350px;" class="center model-img">
                        <figcaption style="text-align: center; margin-top: 8px; font-size: 0.9em; font-style: italic; color: #555;">
                            Image Source: https://ekamperi.github.io/machine%20learning/2021/06/11/acquisition-functions.html
                        </figcaption>
                    </figure>
                </div>
            </div>
        </div>
    """
    )
)

# Surrogate Model Methods Tab Content
surr_model_methods_tab_content = layout(
    Div(text="""
        <div class="row">
            <div class="column">
                <figure>
                    <img src="static/GaussianProcess.gif" alt="Image for GP" class="column3-img">
                    <figcaption id="caption-gp">Image Source: https://www.php.cn/faq/662604.html</figcaption>
                </figure>
                <div class="model-container">
                    <h2>Gaussian Process (GP)</h2>
                    <p>The Gaussian Process (GP) is the most commonly used surrogate model in Bayesian Optimization due to its strength in dealing with smooth functions. Unlike other regression models, GP uses a distribution over possible functions that
                        could explain the observed data. This can be visualized as each point along this surrogate function having its own unique confidence uncertainty and mean prediction. This is done through
                        <span class="tooltip">
                    kernels
                    <span class="tooltip-text">Functions that measure the similarity between two data points. For example, comparing point x to x' to help calculate the mean and uncertainty.</span>
                        </span>. All the points together create the confidence interval used by the acquisition function to make predictions.
                    </p>
                </div>
            </div>
            <div class="column">
                <figure>
                    <img src="static/RandomForests.jpg" alt="Image for RF" class="column3-img">
                    <figcaption id="caption-rf">Image Source: https://medium.com/@roiyeho/random-forests-98892261dc49</figcaption>
                </figure>
                <div class="model-container">
                    <h2>Random Forest (RF)</h2>
                    <p>As per what it sounds like, Random Forest (RF) is a “forest.” This “forest” is a large group of many decision trees that each have slightly different approximations of the true function that may give different results. These different
                        functions are based off of a
                        <span class="tooltip">
                    bootstrap method
                    <span class="tooltip-text">A method where new training sets are created by randomly selecting data points with replacement from the original set.</span>
                        </span>. These may look like A, B, C, etc. where a random combination of these parameters are made to be some like A, A, C or B, A, C where either a condition(s) is not accounted for, the order is randomized, or a combination
                        of both. Each tree will be assigned a bootstrap to be trained on. The result of these decision trees are averaged to find an average result. This result is then also used to predict the variance in the surrogate by comparing
                        the average result to each result of each decision tree.</p>
                </div>
            </div>
            <div class="column">
                <figure>
                    <img src="static/ExtraTrees.png" alt="Image for ET" class="column3-img">
                    <figcaption id="caption-et">Image Source: https://www.researchgate.net/figure/Shows-the-diagram-of-the-extra-trees-regressor-32_fig1_392660477</figcaption>
                </figure>
                <div class="model-container">
                    <h2>Extra Trees (ET)</h2>
                    <p>Extra trees (ET) can be confused with RF due to their similarity in use of decision trees. However, there are key differences between the two. For instance, ET does NOT use bootstrapping. ET uses also increases the randomness at
                        the node. Each decision node makes decisions randomly, once again, unlike RF which proactively tries to make the best decision. ET really emphasizes randomness. The prediction from each of these trees and then average and a
                        confidence limit is derived based on the variance in predictions.</p>
                </div>
            </div>
        </div>
    """
    )
)

# Acquisition Function Methods Tab Content
acq_func_methods_tab_content = layout(
    Div(text="""
        <div class="row">
            <div class="column">
                <div class="model-container">
                    <h2>Expected Improvement (EI)<br>& Probable Improvement (PI)</h2>
                    <p>EI uses the known data points and the unknown areas in order to predict the magnitude of improvement of a prediction to help decide which prediction to make. PI focuses on predicting a spot with the highest chance of improvement.
                        Comparing these two, EI could be said to explore more in order to find that big jump in improvement while EI is more conservative and makes guesses closer to known good values in order to see any improvement.</p>
                    <h2>Lowest Confidence Boundary (LCB)</h2>
                    <p>LCB will look for low valued areas then exploit and exploit off of that. LCB is usually used for minimization.</p>
                </div>
            </div>
            <div class="column">
                <div class="model-container">
                    <h2>GP Hedge</h2>
                    <p>Unlike the other acquisition methods in this module, GP Hedge uses multiple strategies, and in fact, it combines the previous three strategies. This uses a softmax which is just the way GP Hedge gives a probability of improvement
                        to each acquisition strategy. This is then converted to a number that helps decide which one to test. The strategy will then be given a score. This will be repeated until the best acquisition function is decided.
                    </p>
                    <figure>
                        <img src="static/generalacquisitionfunction.png" alt="gerneral acquisition function" class="column-img">
                        <figcaption>Image Source: https://www.researchgate.net/figure/Acquisition-functions-computed-from-eight-observations-green-of-an-otherwise-unknown_fig4_322306222?__cf_chl_tk=6CMGvV628QdPH540UlF6yilT.szL7MXFDZC_lTQf9lA-1750786891-1.0.1.1-C.xnlFsXMGOfVK1z6op7MwsR9BAD6ie_PzThDwFCKcc</figcaption>
                    </figure>
                </div>
            </div>
        </div>
    """
    )
)

# Sampling Methods Tab Content
sampling_methods_tab_content = layout(
    Div(text="""
        <div class="row">
            <div class="column">
                <div class="model-container">
                    <h2>Random Sampling</h2>
                    <p>It's as basic as they come. In random sampling, any part of the population has an equal chance of being selected. For the PBR, any set of parameters is just as likely to be sampled as the next.
                    </p>
                    <br>
                    <br>
                    <br>
                    <br>
                    <br>
                    <br>
                    <br>
                    <figure>
                        <img src="static/RandomSampling.png" alt="Image for Random Sampling" class="column3-img">
                        <figcaption>Image Source: https://www.researchgate.net/figure/Static-sampling-strategies-A-Random-sampling-B-Latin-hypercube-sampling-C-Sobol_fig1_370656695</figcaption>
                    </figure>
                </div>
            </div>
            <div class="column">
                <div class="model-container">
                    <h2>Sobol</h2>
                    <p>This and LHS are quasi-random sampling methods. Quasi random sampling is random to an extent but with that catch that there will not be large spaces without a sample taken unlike what is possible in random sampling. Sobol is deterministic
                        which means that if given a set of data or like the parameters in the PBR, the sampling will always result as the same (unlike random sampling where it is random every time). Sobol also is effective for sampling higher dimensioned
                        problems.
                    </p>
                    <br>
                    <figure>
                        <img src="static/Sobol.png" alt="Image for Sobol" class="column3-img">
                        <figcaption>Image Source: https://www.researchgate.net/figure/Static-sampling-strategies-A-Random-sampling-B-Latin-hypercube-sampling-C-Sobol_fig1_370656695</figcaption>
                    </figure>
                </div>
            </div>
            <div class="column">
                <div class="model-container">
                    <h2>Latin Hypercube Sampling</h2>
                    <p>Latin Hypercube Sampling (LHS) is another quasi-random sampling technique that is in between random sampling and sobol. The way this method works is by ensuring each variable/parameters range is covered. An easy way to visualize
                        this is by imagining ingredients for a cake. The samples could be 1-2 cups of flour, 2-3 cups of flour, and 3-4 cups of flour. While it does not matter where in the range of cups is chosen, the sample must cover that area such
                        as sampling 1.1, 2.5, and 3.2 cups.</p>
                    <figure>
                        <img src="static/LHS.png" alt="Image for LHS" class="column3-img">
                        <figcaption>Image Source: https://www.researchgate.net/figure/Static-sampling-strategies-A-Random-sampling-B-Latin-hypercube-sampling-C-Sobol_fig1_370656695</figcaption>
                    </figure>
                </div>
            </div>
        </div>
    """
    )
)

# Instructions Tab Content
instructions_tab_content = layout(
    Div(text="""
        <div class="model-section">
            <div class="text-content">
                <h2>How to use the module:</h2>
                <ol>
                    <li>
                        <h3>Define Parameter Search Space</h3>
                        <p>This is where you will define the range for each parameter. Defining the range tells the machine what range it is allowed to make guesses from. The first parameters you can vary are the initial concentration of biomass and
                            initial concentration of nitrate. These materials are already in the reactor at the start of the experiment. You will then change the flowrate and the concentration of nitrate in. This lets the machine know how much nitrate
                            will be entering the reactor at the start of the experiment and rate of entry. Finally the initial light intensity can be manipulated which is the amount of light being shined through the reactor glass.
                        </p>
                    </li>
                    <li>
                        <h3>Configure Initial Sampling & Model</h3>
                        <p>In this section, you can choose the surrogate model, acquisition function, sampling method, and number of
                            <span class="tooltip">
                            initial points
                            <span class="tooltip-text">The starting dataset that BO will use to make the first prediction.</span>
                            </span>.
                        </p>
                    </li>
                    <li>
                        <h3>Run Experiment Workflow</h3>
                        <p>Once the first two sections have been set-up and chosen, the final step is the start running the experiment. The first part is to generate the inital data points. Next, calculate lutein for those data points. Then, showthe
                            prediction and the suggested next epxperiment. Based of of the inital trial and first optimization run, a suggested point from the model will be created. This suggested run can then be ran and produce an updated model as
                            a result. This process may be
                            <span class="tooltip">
                            repeated
                            <span class="tooltip-text">Back and forth between buttons C & D</span>
                            </span>
                            until the user is happy with their optimized result. The experiment can then be reset to try other models.</p>
                    </li>
                </ol>
            </div>
            <div class="image-container">
                <br><br><br><br><br>
                <img src="static/step1.png" alt="Image for step 1" class="model-img" width="300px" height="100%">
                <br><br>
                <img src="static/step2.png" alt="Image for step 2" class="model-img" width="180px" height="100%">
                <br><br>
                <img src="static/step3.png" alt="Image for step 3" class="model-img" width="400px" height="100%">
            </div>
        </div>
    """
    )
)

# Questions Tab Content
questions_tab_content = layout(
    Div(text="""
        <h3>Guiding Questions:</h3>
        <div class="row">
            <div class="column_2">
                <h3>Parameter Questions:</h3>
                <p>
                    <ol type="1">
                        <li>What is the optimal lutein concentration with the default settings on the module?</li>
                        <li>How does the optimal lutein concentration change when the light intensity range slider is shifted to 300-400 μmol/m<sup>2</sup>s</li>
                        <li>How does the optimal lutein concentration change when the initial concentration of biomass is increased to 5-6 g/L? Repeat this for the inital nitrate concentration. Which one seems to have a greater effect on lutein concetration?
                            Does this make sense?</li>
                        <li>Increase inltet nitrate's concentration range to 20-30 g/L. What effect does this have on lutein concentration. After testing this question and question 3, what does the overall trend for lutein concentration seem to be when
                            initial concentrations are increased?</li>
                        <li>Change the inlet flow rate to 0.0750-0.1001 L/h. What is the value of lutein's concentration? Why does the concentration increase/decrease like this compared to question 1.</li>
                    </ol>
                </p>
            </div>
            <div class="column_2">
                <h3>Modeling Questions:</h3>
                <ol type="1" start="6">
                    <li>When the default settings of the moduel are used, the optimal lutein outcome should be 0.0107 g/L. Try each surrogate model with 10 initial points and 10 additonal trials, or until 0.0107 g/L of lutein is reached. Do this three
                        times for each. Which model seems to be the best fit for this PBR?</li>
                    <li>Repeat question 6 for each acquisition function.</li>
                    <li>Repeat question 6 for each sampling method.</li>
                    <li>Change the initial samples to 5. Run a few trials until 0.0107 g/L is reached, and then average the number of additional trials to reach that lutein concentration. Do this for 15 intial samples too. Based off of comparing the averages
                        of additional trials needed, does having more inital samples before bayesian optimization is used help speed up the computational arrival to optimal lutein concentration?</li>
                </ol>
                </p>
            </div>
        </div>
    """
    )
)


controls_col = column(
    title_div, description_p,
    objective_title, objective_select, time_hours_input,
    param_range_title, cx0_range, cn0_range, fin_range, cnin_range, i0_range,
    settings_title, surrogate_select, acq_func_select, sampler_select, n_initial_input,
    actions_title, generate_button, calculate_button, suggest_button, suggestion_div, run_suggestion_button, reset_button,
    status_div,
    width=470,
)

results_col = column(
    data_table, 
    results_div, 
    p_conv, 
    p_sim,
    indicator_panel_title,
    indicator_panel
)

# Main layout for the "Run Optimizer" TabPanel
train_and_validate_tab_layout = row(controls_col, results_col)


# --- Define the main Tabs object ---
main_tabs = Tabs(tabs=[
    TabPanel(child=about_tab_content, title='About'),
    TabPanel(child=photobioreactor_tab_content, title='Photobioreactor'),
    TabPanel(child=bo_model_tab_content, title='BO Model'),
    TabPanel(child=surrogate_acq_func_tab_content, title='Surrogate Model / Acquisition Function'),
    TabPanel(child=surr_model_methods_tab_content, title='Surr. Model Methods'),
    TabPanel(child=acq_func_methods_tab_content, title='Acq. Func. Methods'),
    TabPanel(child=sampling_methods_tab_content, title='Sampling Methods'),
    TabPanel(child=instructions_tab_content, title='Instructions'),
    TabPanel(child=questions_tab_content, title='Questions'),
    TabPanel(child=train_and_validate_tab_layout, title='Run Optimizer', name='run_optimizer_tab'), # Added a 'name' for easy lookup
])

# CustomJS callback to switch tabs when "Jump to Module" is clicked
jump_to_optimizer_button.js_on_click(CustomJS(args=dict(tabs=main_tabs), code="""
    // Find the index of the 'Run Optimizer' tab by its name or title
    let target_tab_index = -1;
    for (let i = 0; i < tabs.tabs.length; i++) {
        if (tabs.tabs[i].title === 'Run Optimizer' || tabs.tabs[i].name === 'run_optimizer_tab') {
            target_tab_index = i;
            break;
        }
    }
    if (target_tab_index !== -1) {
        tabs.active = target_tab_index;
    }
"""))


# Add the main Tabs object as the root of the document
curdoc().add_root(main_tabs)

# Initialize UI (keep these, they are important for initial state)
# These functions should use the globally defined 'doc' object.
set_optimization_mode()
set_ui_state()      html part 2 <!DOCTYPE HTML>
<html>

<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    <title>Bayesian Optimization</title>
    <style>
        /* -------------------------BODY------------------------- */
        
        body {
            margin: 0;
            background: #fff;
            font-family: 'Arial', sans-serif;
            font-weight: 400;
        }
        /* ------------------------- HEADER -------------------------*/
        
        header {
            background: #262626;
            height: 80px;
        }
        
        header::after {
            content: '';
            display: table;
            clear: both;
        }
        
        .logo {
            padding: 10px;
            float: left;
            width: 300px;
        }
        
        .sq-logo {
            padding: 10px;
            float: left;
            width: 65px;
            height: 65px;
            object-fit: cover;
        }
        
        nav {
            float: right;
            padding-right: 16px;
        }
        
        nav ul {
            margin: 0;
            padding: 0;
            list-style: none;
        }
        
        nav li {
            margin: 0 2.28vw;
            position: relative;
            float: left;
            height: 80px;
            display: flex;
            align-items: center;
        }
        
        nav a {
            color: rgb(255, 251, 251);
            text-decoration: none;
            font-size: 16px;
            text-align: center;
        }
        
        nav a:hover {
            color: #31A6FF;
        }
        
        nav a::before {
            content: '';
            display: block;
            height: 5px;
            background-color: #31A6FF;
            position: absolute;
            width: 0%;
            top: 0;
            transition: all ease-in-out 250ms;
        }
        
        nav a:hover::before {
            width: 100%;
        }
        
        .header-text {
            font-size: 16px;
        }
        
        @media all and (max-width: 608px) {
            header {
                height: 160px;
                display: flex;
                flex-direction: column;
                align-items: center;
            }
            nav {
                float: none;
            }
            nav ul {
                display: flex;
                justify-content: center;
                padding: 0;
            }
        }
        
        .dropdown {
            float: left;
            overflow: hidden;
        }
        
        .dropdown .dropbtn {
            padding: 0;
            font-size: 16px;
            background-color: transparent;
            color: rgb(255, 251, 251);
            text-decoration: none;
            border: none;
            margin-top: -1.2px;
        }
        
        .dropbtn::before {
            content: '';
            display: block;
            height: 5px;
            background-color: #31A6FF;
            position: absolute;
            width: 0%;
            top: 0;
            transition: all ease-in-out 250ms;
        }
        
        .dropbtn:hover::before {
            width: 100%
        }
        
        .dropdown-content {
            display: none;
            position: absolute;
            top: 80px;
            left: -20%;
            width: 200%;
            background-color: #5c5c5c;
            z-index: 1;
        }
        
        .dropdown-content a {
            float: none;
            padding: 12px 16px;
            text-decoration: none;
            color: white;
            display: block;
            text-align: left;
        }
        
        .dropdown-content a:hover::before {
            width: 0;
        }
        
        .dropdown:hover .dropdown-content {
            display: block;
        }
        
        .dropdown:hover .dropbtn::before {
            width: 100%
        }
        
        .dropdown:hover .dropbtn {
            color: #31A6FF
        }
        
        li:hover .dropdown-content {
            display: block;
        }
        /* -------------------------TABS (Bokeh)------------------------- */
        /* These will style the Bokeh-generated tabs */
        
        .bk-tabs-header .bk-tab-button {
            background-color: inherit;
            /* Should match parent background or f1f1f1 */
            border: none;
            outline: none;
            cursor: pointer;
            padding: 14px 16px;
            transition: 0.3s;
            font-size: 17px;
            float: left;
            /* Keep buttons aligned */
        }
        
        .bk-tabs-header .bk-tab-button:hover {
            background-color: #ddd;
        }
        
        .bk-tabs-header .bk-tab-button.bk-active {
            background-color: #ccc;
        }
        
        .bk-tab-panel {
            display: block;
            /* Bokeh handles visibility, but ensure default is block */
            padding: 6px 12px;
            border: 1px solid #ccc;
            /* Add border for content area */
            border-top: none;
            /* No top border as it connects to tab header */
            background-color: #f1f1f1;
            /* Match background for content */
        }
        /* -------------------------ROWS AND COLUMNS (for content within Divs) -------------------------*/
        
        .home_container {
            display: grid;
            grid-template-columns: 1fr auto;
            gap: 0.75%;
            margin-left: auto;
            margin-right: auto;
            align-items: stretch;
            max-width: 1200px;
            width: 100%;
            padding: 0 20px;
            box-sizing: border-box;
        }
        
        .column_1_home {
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }
        
        .column_2_home {
            display: flex;
            align-items: stretch;
            align-items: first baseline;
        }
        
        .column_2_home img {
            width: auto;
            max-width: 800px;
            height: 100%;
            object-fit: contain;
        }
        /* Generic column styles (used in multiple tab contents) */
        
        .row {
            display: flex;
            gap: 20px;
            /* Default gap for rows within content */
            margin: 20px;
            /* Default margin for rows within content */
        }
        
        .column {
            flex: 1;
            padding: 10px;
            border-radius: 10px;
        }
        
        .model-container {
            border: 0px;
            /* No border by default */
            padding: 10px;
            margin-top: 10px;
        }
        
        .model-container p {
            text-align: center;
        }
        
        .center-img {
            display: block;
            margin-left: auto;
            margin-right: auto;
        }
        
        .column3-img {
            /* Specific to Surr. Model Methods and Sampling Methods */
            display: block;
            margin: 0 auto 10px auto;
            width: 300px;
            height: 185px;
            border-radius: 8px;
        }
        
        figure {
            margin: 0;
        }
        
        figcaption {
            text-align: center;
            margin-top: 8px;
            font-style: italic;
            color: #555;
            font-size: 0.9em;
            /* Default font size for captions */
        }
        /* Specific caption sizes from your original code */
        
        #caption-gp {
            font-size: 12px;
        }
        
        #caption-rf {
            font-size: 10px;
        }
        
        #caption-et {
            font-size: 6px;
        }
        /* Specific styles for Acq. Func. Methods images and captions */
        
        .column-img {
            /* used for generalacquisitionfunction.png */
            display: block;
            margin: 20px auto 10px auto;
            width: 400px;
            height: auto;
            border-radius: 8px;
        }
        /* Your original code had a conflicting '.column-img' which set height:auto for the acquisition function image
           and a generic '.column-img' which set a fixed height for other images. I've separated them.
           If you had a specific small font size for Acq. Func. Methods figcaption, re-add it like this: */
        
        .acq-func-figcaption {
            font-size: 0.4em !important;
        }
        /* Styles for Photobioreactor Tab Specifics */
        
        .left-section {
            flex: 1;
            padding: 10px;
        }
        
        .right-column-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .top-right-section {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .bottom-right-section {
            flex: 1;
            padding: 10px;
        }
        
        .columni-img {
            /* Specific to Photobioreactor image */
            width: 100%;
            max-width: 600px;
            height: 325px;
            border-radius: 8px;
        }
        /* Styles for BO Model and Instructions Tab Specifics */
        
        .model-section {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 40px;
            padding: 40px;
            margin: 0 auto;
            max-width: 1000px;
        }
        
        .text-content {
            flex: 3;
            text-align: left;
        }
        
        .image-container {
            flex: 2;
            text-align: center;
        }
        
        .model-img {
            /* used in BO Model and Instructions */
            max-width: 100%;
            height: 200px;
            border-radius: 8px;
        }
        /* Responsive for model-section */
        
        @media (max-width: 768px) {
            .model-section {
                flex-direction: column;
            }
        }
        /* Column for Questions Tab (renamed from .column_2 to avoid conflict with flex-based .column) */
        
        .question-column {
            float: left;
            width: 45.9%;
            /* Approx half width */
            padding-left: 2%;
            padding-right: 2%;
        }
        /* -------------------TOOLTIPS--------------------- */
        
        .tooltip {
            position: relative;
            display: inline-block;
            text-decoration: underline;
            text-decoration-style: dotted;
            text-decoration-thickness: 1px;
            text-decoration-color: #484848;
        }
        
        .tooltip .tooltiptext {
            visibility: hidden;
            width: 130px;
            /* Reduced width from 220px to fit original HTML structure */
            bottom: 100%;
            left: 50%;
            margin-left: -65px;
            /* Adjust margin for new width */
            background-color: #262626;
            color: #fff;
            font-size: 14px;
            /* Default font size for general tooltips */
            text-align: center;
            padding: 5px;
            border-radius: 6px;
            position: absolute;
            z-index: 1;
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        .tooltip .tooltiptext::after {
            content: " ";
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: #262626 transparent transparent transparent;
        }
        
        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }
        /* Specific tooltip text for "black box functions" etc from BO Model tab */
        
        .text-content .tooltip .tooltip-text {
            width: 220px;
            /* Override width for these specific tooltips */
            margin-left: -110px;
            font-size: 14px;
        }
        /*-------------------BOKEH SECTION--------------------- */
        
        .scrollable-container {
            width: 100%;
            max-width: 100%;
            overflow-x: auto;
            /* Added padding-top to prevent content from hiding under header */
            padding-top: 20px;
            box-sizing: border-box;
            /* Include padding in width calculation */
        }
        /*-------------------FOOTER--------------------- */
        
        .footer {
            margin: 0;
            padding: 10px 0 10px 0;
            list-style: none;
            text-decoration: none;
            overflow: hidden;
            box-sizing: border-box;
            background-color: #262626;
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            font-family: 'Arial', sans-serif;
        }
        
        @media all and (max-width: 700px) {
            .footer {
                flex-direction: column;
            }
        }
        
        .container2 {
            display: flex;
            align-items: center;
            justify-content: center;
            flex-wrap: nowrap;
            padding: 10px;
        }
        /* -------------------MISC------------------- */
        
        .button1 {
            /* This style might not apply directly to Bokeh buttons, use .bk-btn classes if needed */
            margin: 0;
            justify-self: center;
            text-decoration: none;
            color: black;
            font-family: 'Arial', sans-serif;
            font-weight: 200;
            font-size: 28px;
            text-align: center;
            background-color: #fff;
            border: solid 2px black;
            border-radius: 50px;
            padding: 0.651vw 5.208vw;
            -webkit-transition-duration: 300ms;
            transition-duration: 300ms;
        }
        
        .caption {
            /* This might be redundant if figcaption is styled */
            font-size: 12px;
            justify-items: center;
            display: grid;
        }
        
        .center {
            display: block;
            margin-left: auto;
            margin-right: auto;
            width: 52.083vw;
            height: 29.297vw;
        }
        
        .head1 {
            text-align: center;
            background-color: #fff;
            color: #000;
            font-size: 32px;
            font-weight: bold;
            font-family: 'Arial', sans-serif;
        }
        /* General styles for Bokeh-rendered HTML content */
        
        .bk-root {
            background-color: #f1f1f1;
            /* Background for the entire Bokeh app area */
        }
        
        .bk-layout-fixed,
        .bk-layout-box {
            padding: 5px;
            /* Add some general padding to Bokeh layouts if needed */
        }
        
        h3 {
            font-size: 18px;
            /* Standardize H3 if it varies */
        }
        
        p {
            font-size: 16px;
            /* Standardize Paragraph font size */
        }
    </style>
</head>

<body>
    <header>
        <div>
            <a href="/BO_final"><img src="static/Logo2.JPG" alt="logo" class="logo"></a>
        </div>
        <nav>
            <li><a href="/BO_final" class="header-text">HOME</a></li>
            <li>
                <div class="dropdown">
                    <button class="dropbtn">MODULES</button>
                    <div class="dropdown-content">
                        <a href="/BO_final" class="header-text">Bayesian Optimization</a>
                        <a href="/biodegradability_classification" class="header-text">Biodegradability Classification</a>
                        <a href="/catalysis_data_interactive_visualization" class="header-text">Catalysis Data Science</a>
                        <a href="/DLT" class="header-text">Digital Lab Twin</a>
                        <a href="/DAC" class="header-text">Direct Air Captures</a>
                        <a href="/sliders_reaction_kinetics" class="header-text">Reaction Kinetics</a>
                        <a href="/SIR" class="header-text">SEIR Infectious Diseases</a>
                        <a href="/ZECC" class="header-text">Zero Energy Cooling Chamber</a>
                    </div>
                </div>
            </li>
            <li><a href="/static/about.html" class="header-text">ABOUT</a></li>
        </nav>
    </header>
    <h1 class="head1">Bayesian Optimization</h1>

    <div class="scrollable-container">
        {{ bokeh_script | safe }} {{ bokeh_div | safe }}
    </div>

    <br>
    <br>
</body>

<div class="footer">
    <a href="https://cache.org/"><img src="static/cache_logo.png" alt="cache" class="sq-logo" ;></a>
    <a href="https://www.nsf.gov/"><img src="static/nsf_logo.png" alt="nsf" class="sq-logo" ;></a>
    <a href="/BO_final"><img src="static/Logo2.JPG" alt="logo" class="logo" ;></a>
    <a href="https://engineering.lehigh.edu/chbe"><img src="static/chbe_logo.png" alt="chbe" class="sq-logo" ;></a>
    <a href="https://creativeinquiry.lehigh.edu/"><img src="static/creative_inquiry_logo.png" alt="ci" class="sq-logo" ;></a>
</div>

</html>
